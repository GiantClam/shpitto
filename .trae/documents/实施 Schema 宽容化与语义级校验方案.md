您提出的观点非常务实。**“代码兜底 + AI 生成”** 确实是目前工程实践中的最佳平衡点。

既然 LLM（尤其是 Gemini Flash）在处理嵌套 JSON 时，确实很难 100% 稳定地生成 `{"items": [...]}` 这种多层嵌套结构，强行要求它反而会导致任务成功率大幅下降，陷入无休止的重试。

**因此，接受 `List` 并通过代码将其标准化为 `Dict`，是解决此问题的最佳方案（Best Practice）。** 这既保证了系统的鲁棒性，又降低了对模型智力的即时要求。

### 最终实施方案：Schema 自愈 + 语义清洗

我将撤回之前的“纯 AI 修正”路线，转而采用您建议的“代码转换”路线。

#### 1. Schema 层的智能转换 (project.py)
在 `PuckItem` 模型中，使用 Pydantic 的 `mode='before'` 校验器。这是 Pydantic V2 提供的强大功能，它允许我们在数据进入严格校验**之前**，先对原始数据进行“整形”。

*   **逻辑**：
    *   拦截 `props` 字段。
    *   如果它是 `List`（数组），我们不再报错，而是假设它是 `items` 的内容，自动将其包装为 `{'items': [...]}`。
    *   如果它是 `Dict`（对象），则保持不变。
*   **优势**：这从根本上消除了 `ValidationError`，让数据能够顺利流转到后续环节。

#### 2. Architect 层的提示词简化 (architect.py)
虽然我们有了代码兜底，但我们仍应在 Prompt 中保留正确的格式要求，作为“软约束”。不过，我们可以稍微降低语气的严厉程度，避免模型因为过分紧张而产生其他幻觉。

#### 3. Critic 层的逻辑回归 (architect.py)
既然 Schema 已经解决了格式问题，`Critic Agent` 就不需要再处理“props 是数组还是对象”这种低级错误了。它可以腾出手来，专注于更高级的**业务逻辑校验**：
*   “首页是否缺少 Hero 区域？”
*   “产品页是否有 ProductGrid？”
*   “Navbar 是否包含 Logo？”

### 执行计划
1.  **修改 Schema**: 在 `apps/backend/schema/project.py` 中添加 `fix_props_list` 校验器（复活并优化之前的逻辑）。
2.  **验证**: 重启服务，重新生成。您会发现之前的 `ValidationError` 消失了，AI 生成的网站将一次性通过校验并渲染出来。

这将为您带来最流畅的用户体验。